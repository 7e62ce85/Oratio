"""
CP Post Blocker Middleware
===========================
Blocks direct access to CP-reported posts via nginx reverse proxy check.
This module provides an endpoint that nginx can call to verify if a post should be blocked.
"""

from flask import Blueprint, request, jsonify
import sqlite3
import logging
import os

logger = logging.getLogger(__name__)

cp_blocker_bp = Blueprint('cp_blocker', __name__)

DB_PATH = os.environ.get('PAYMENT_DB_PATH', '/data/payments.db')

def get_blocked_post_ids():
    """Get list of post IDs that should be blocked (content_hidden=1)"""
    try:
        conn = sqlite3.connect(DB_PATH, timeout=5)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT content_id FROM cp_reports 
            WHERE content_type = 'post' AND content_hidden = 1
        ''')
        post_ids = [row[0] for row in cursor.fetchall()]
        conn.close()
        return set(post_ids)
    except Exception as e:
        logger.error(f"Error fetching blocked post IDs: {e}")
        return set()

@cp_blocker_bp.route('/api/cp/check-post-access/<int:post_id>', methods=['GET'])
def check_post_access(post_id):
    """
    Check if a post should be blocked.
    Returns: 
      200 {"allowed": true} if accessible
      403 {"allowed": false, "reason": "..."} if blocked
    
    Admin users can always access CP-reported posts.
    """
    logger.info(f"üîç [CP POST BLOCKER] Checking access to post {post_id}")
    logger.info(f"üç™ [CP POST BLOCKER] Cookies: {request.cookies}")
    
    # Check if user is admin (via JWT from cookie)
    # Admin is always person_id = 1 in Lemmy
    jwt_token = request.cookies.get('jwt')
    logger.info(f"üîë [CP POST BLOCKER] JWT token present: {bool(jwt_token)}")
    
    if jwt_token:
        try:
            import jwt as pyjwt
            decoded = pyjwt.decode(jwt_token, options={"verify_signature": False})
            person_id = decoded.get('sub')
            
            # Admin user (quick check)
            logger.info(f"üë§ [CP POST BLOCKER] Decoded person_id: {person_id}")
            if person_id == 1:
                logger.info(f"‚úÖ [CP POST BLOCKER] Admin access to post {post_id} - ALLOWED")
                return jsonify({"allowed": True, "admin": True}), 200

            # Moderators (and reviewers) stored in our local user_cp_permissions table
            try:
                conn = sqlite3.connect(DB_PATH, timeout=5)
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT can_review_cp FROM user_cp_permissions WHERE person_id = ?
                ''', (person_id,))
                row = cursor.fetchone()
                conn.close()

                if row and row[0]:
                    logger.info(f"Moderator/reviewer access to post {post_id} for person_id={person_id} - ALLOWED")
                    return jsonify({"allowed": True, "moderator": True}), 200
            except Exception as e:
                logger.error(f"Error checking moderator permissions: {e}")
        except Exception as e:
            logger.error(f"Error decoding JWT: {e}")
    
    blocked_posts = get_blocked_post_ids()
    logger.info(f"üö´ [CP POST BLOCKER] Blocked posts: {blocked_posts}")
    
    if post_id in blocked_posts:
        logger.info(f"‚ùå [CP POST BLOCKER] Post {post_id} is blocked - denying access")
        return jsonify({
            "allowed": False,
            "reason": "Content unavailable (removed or under review)"
        }), 403
    
    logger.info(f"‚úÖ [CP POST BLOCKER] Post {post_id} not blocked - allowing access")
    return jsonify({"allowed": True}), 200


@cp_blocker_bp.route('/api/cp/check-post-uri', methods=['GET'])
def check_post_uri():
    """
    Check if a post should be blocked based on X-Original-URI header.
    Nginx passes the original request URI, we extract post_id from it.
    
    Returns: 
      200 if accessible
      403 if blocked
    """
    import re
    
    original_uri = request.headers.get('X-Original-URI', '')
    logger.info(f"üîç [CP POST BLOCKER] Checking URI: {original_uri}")
    
    # Extract post_id from URI like "/post/136"
    match = re.search(r'/post/(\d+)', original_uri)
    if not match:
        logger.warning(f"‚ö†Ô∏è [CP POST BLOCKER] Could not extract post_id from URI: {original_uri}")
        return '', 200  # Allow if we can't determine post_id
    
    post_id = int(match.group(1))
    logger.info(f"üìù [CP POST BLOCKER] Extracted post_id: {post_id}")
    
    # Check if user is admin (via JWT from cookie)
    jwt_token = request.cookies.get('jwt')
    logger.info(f"üîë [CP POST BLOCKER] JWT token present: {bool(jwt_token)}")
    
    if jwt_token:
        try:
            import jwt as pyjwt
            decoded = pyjwt.decode(jwt_token, options={"verify_signature": False})
            person_id = decoded.get('sub')
            
            logger.info(f"üë§ [CP POST BLOCKER] Decoded person_id: {person_id}")
            
            # Admin user (person_id = 1)
            if person_id == 1:
                logger.info(f"‚úÖ [CP POST BLOCKER] Admin access to post {post_id} - ALLOWED")
                return '', 200  # 200 = allowed

            # Moderators (can_review_cp = 1)
            try:
                conn = sqlite3.connect(DB_PATH, timeout=5)
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT can_review_cp FROM user_cp_permissions WHERE person_id = ?
                ''', (person_id,))
                row = cursor.fetchone()
                conn.close()

                if row and row[0]:
                    logger.info(f"‚úÖ [CP POST BLOCKER] Moderator access to post {post_id} - ALLOWED")
                    return '', 200  # 200 = allowed
            except Exception as e:
                logger.error(f"‚ùå [CP POST BLOCKER] Error checking moderator permissions: {e}")
        except Exception as e:
            logger.error(f"‚ùå [CP POST BLOCKER] Error decoding JWT: {e}")
    
    # Check if post is CP hidden
    blocked_posts = get_blocked_post_ids()
    logger.info(f"üö´ [CP POST BLOCKER] Blocked posts: {blocked_posts}")
    
    if post_id in blocked_posts:
        logger.info(f"‚ùå [CP POST BLOCKER] Post {post_id} is blocked - denying access")
        return '', 403  # 403 = blocked
    
    logger.info(f"‚úÖ [CP POST BLOCKER] Post {post_id} not blocked - allowing access")
    return '', 200  # 200 = allowed


@cp_blocker_bp.route('/api/cp/check-post-uri', methods=['GET'])
def check_post_uri():
    """
    Check if a post should be blocked by parsing X-Original-URI header.
    Used by nginx auth_request.
    """
    import re
    
    original_uri = request.headers.get('X-Original-URI', '')
    logger.info(f"üîç [CP POST BLOCKER] Checking URI: {original_uri}")
    
    # Extract post_id from URI like /post/136
    match = re.match(r'^/post/(\d+)', original_uri)
    if not match:
        logger.warning(f"‚ö†Ô∏è [CP POST BLOCKER] Could not extract post_id from URI: {original_uri}")
        return '', 200  # Allow if we can't parse (fail open for non-post URIs)
    
    post_id = int(match.group(1))
    logger.info(f"üîç [CP POST BLOCKER] Extracted post_id: {post_id}")
    
    # Check if user is admin (via JWT from cookie)
    jwt_token = request.cookies.get('jwt')
    logger.info(f"üîë [CP POST BLOCKER] JWT token present: {bool(jwt_token)}")
    
    if jwt_token:
        try:
            import jwt as pyjwt
            decoded = pyjwt.decode(jwt_token, options={"verify_signature": False})
            person_id = decoded.get('sub')
            
            # Admin user (quick check)
            logger.info(f"üë§ [CP POST BLOCKER] Decoded person_id: {person_id}")
            if person_id == 1:
                logger.info(f"‚úÖ [CP POST BLOCKER] Admin access to post {post_id} - ALLOWED")
                return '', 200

            # Moderators (and reviewers) stored in our local user_cp_permissions table
            try:
                conn = sqlite3.connect(DB_PATH, timeout=5)
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT can_review_cp FROM user_cp_permissions WHERE person_id = ?
                ''', (person_id,))
                row = cursor.fetchone()
                conn.close()

                if row and row[0]:
                    logger.info(f"‚úÖ [CP POST BLOCKER] Moderator/reviewer access to post {post_id} for person_id={person_id} - ALLOWED")
                    return '', 200
            except Exception as e:
                logger.error(f"Error checking moderator permissions: {e}")
        except Exception as e:
            logger.error(f"Error decoding JWT: {e}")
    
    blocked_posts = get_blocked_post_ids()
    logger.info(f"üö´ [CP POST BLOCKER] Blocked posts: {blocked_posts}")
    
    if post_id in blocked_posts:
        logger.info(f"‚ùå [CP POST BLOCKER] Post {post_id} is blocked - denying access")
        return '', 403
    
    logger.info(f"‚úÖ [CP POST BLOCKER] Post {post_id} not blocked - allowing access")
    return '', 200

