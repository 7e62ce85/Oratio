from flask import Flask, jsonify, request, render_template, redirect, url_for, session
from flask import send_from_directory
import uuid
import time
import json
import os
import requests
from datetime import datetime, timedelta
import qrcode
from io import BytesIO
import base64
import sqlite3
import hashlib
import hmac
import threading
import logging
import traceback
from functools import wraps
from werkzeug.exceptions import BadRequest
from direct_payment import direct_payment_handler

# 로깅 설정 - 먼저 로거를 초기화해야 함
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('bch_payment.log')
    ]
)
logger = logging.getLogger('bch_payment')

# 직접 결제 모듈 가져오기
try:
    from direct_payment import direct_payment_handler
    DIRECT_MODE = True  # 항상 직접 결제 모드 사용
    logger.info("직접 결제 모드 활성화")
except ImportError:
    DIRECT_MODE = False
    logger.error("직접 결제 모듈을 불러올 수 없습니다. 시스템이 작동하지 않을 수 있습니다.")

# 환경 변수에서 지갑 주소 가져오기
PAYOUT_WALLET = os.environ.get('PAYOUT_WALLET', 'bitcoincash:qr3jejs0qn6wnssw8659duv7c3nnx92f6sfsvam05w')

app = Flask(__name__)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', os.urandom(24))

# 환경 설정
MOCK_MODE = os.environ.get('MOCK_MODE', 'false').lower() == 'true'
ELECTRON_CASH_URL = os.environ.get('ELECTRON_CASH_URL', 'http://electron-cash:7777')  # 더 이상 사용하지 않음
LEMMY_API_URL = os.environ.get('LEMMY_API_URL', 'http://lemmy:8536')
LEMMY_API_KEY = os.environ.get('LEMMY_API_KEY', '')
TESTNET = os.environ.get('TESTNET', 'false').lower() == 'true'  # 기본값 false로 변경 (실제 결제 사용)
MIN_CONFIRMATIONS = int(os.environ.get('MIN_CONFIRMATIONS', '1'))
MIN_PAYOUT_AMOUNT = float(os.environ.get('MIN_PAYOUT_AMOUNT', '0.01'))  # 최소 출금 금액
FORWARD_PAYMENTS = os.environ.get('FORWARD_PAYMENTS', 'true').lower() == 'true'

# 데이터베이스 설정
DB_PATH = os.environ.get('DB_PATH', '/data/payments.db')

def init_db():
    """데이터베이스 초기화"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # 인보이스 테이블 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS invoices (
        id TEXT PRIMARY KEY,
        payment_address TEXT NOT NULL,
        amount REAL NOT NULL,
        status TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        expires_at INTEGER NOT NULL,
        paid_at INTEGER,
        user_id TEXT,
        tx_hash TEXT,
        confirmations INTEGER DEFAULT 0
    )
    ''')
    
    # 주소 테이블 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS addresses (
        address TEXT PRIMARY KEY,
        created_at INTEGER NOT NULL,
        used BOOLEAN DEFAULT FALSE
    )
    ''')
    
    # 사용자 크레딧 테이블
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS user_credits (
        user_id TEXT PRIMARY KEY,
        credit_balance REAL DEFAULT 0,
        last_updated INTEGER NOT NULL
    )
    ''')
    
    # 거래 기록 테이블
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS transactions (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        amount REAL NOT NULL,
        type TEXT NOT NULL,
        description TEXT,
        created_at INTEGER NOT NULL,
        invoice_id TEXT,
        FOREIGN KEY(invoice_id) REFERENCES invoices(id)
    )
    ''')
    
    # PoW 검증 테이블 추가
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS pow_verifications (
        id TEXT PRIMARY KEY,
        invoice_id TEXT NOT NULL,
        nonce TEXT NOT NULL,
        hash TEXT NOT NULL,
        verified INTEGER DEFAULT 0,
        verified_at INTEGER NOT NULL,
        user_token TEXT NOT NULL,
        FOREIGN KEY(invoice_id) REFERENCES invoices(id)
    )
    ''')
    
    # PoW 크레딧 테이블 추가
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS pow_credits (
        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
        invoice_id TEXT NOT NULL,
        user_id TEXT NOT NULL,
        amount REAL NOT NULL,
        created_at INTEGER NOT NULL,
        used BOOLEAN DEFAULT FALSE,
        FOREIGN KEY(invoice_id) REFERENCES invoices(id)
    )
    ''')
    
    conn.commit()
    conn.close()
    logger.info("데이터베이스 초기화 완료")

# 데이터베이스 초기화
init_db()

def add_verified_column():
    """필요한 경우 verified 컬럼 추가"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # pow_verifications 테이블의 컬럼 확인
        cursor.execute("PRAGMA table_info(pow_verifications)")
        columns = [column[1] for column in cursor.fetchall()]
        
        # verified 컬럼이 없는 경우 추가
        if 'verified' not in columns:
            logger.info("pow_verifications 테이블에 verified 컬럼 추가 중...")
            cursor.execute("ALTER TABLE pow_verifications ADD COLUMN verified INTEGER DEFAULT 1")
            conn.commit()
            logger.info("verified 컬럼이 성공적으로 추가되었습니다.")
        
        conn.close()
    except Exception as e:
        logger.error(f"verified 컬럼 추가 중 오류: {str(e)}")

# API 인증 데코레이터
def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if not api_key or api_key != LEMMY_API_KEY:
            return jsonify({"error": "Unauthorized"}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
def index():
    """메인 페이지"""
    return render_template('index.html')

@app.route('/health')
def health_check():
    """서비스 상태 확인"""
    return jsonify({
        "status": "ok", 
        "service": "bch-payment-service",
        "mock_mode": MOCK_MODE,
        "testnet": TESTNET,
        "direct_mode": DIRECT_MODE,
        "api": "blockchair.com"  # 사용 중인 API 표시
    })

@app.route('/generate_invoice', methods=['GET'])
def generate_invoice():
    """새 인보이스 생성"""
    # 파라미터 가져오기
    amount = request.args.get('amount', type=float)
    user_id = request.args.get('user_id', '')
    
    if not amount or amount <= 0:
        return jsonify({"error": "Invalid amount"}), 400
    
    # 최소 금액 확인 (실제 구현 시 조정)
    min_amount = 0.0001  # BCH
    if amount < min_amount:
        return jsonify({"error": f"Amount must be at least {min_amount} BCH"}), 400
    
    # 새 인보이스 생성
    invoice_id = str(uuid.uuid4())
    
    # 직접 결제 모드: 항상 동일한 지갑 주소 사용
    payment_address = PAYOUT_WALLET  # 원본: direct_payment_handler.get_address()
    
    # 타임스탬프
    now = int(time.time())
    expires_at = now + 3600  # 1시간 후 만료
    
    # 인보이스 데이터
    invoice_data = {
        "invoice_id": invoice_id,
        "payment_address": payment_address,
        "amount": amount,
        "status": "pending",
        "created_at": now,
        "expires_at": expires_at,
        "user_id": user_id
    }
    
    # 데이터베이스에 저장
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute(
        """INSERT INTO invoices 
           (id, payment_address, amount, status, created_at, expires_at, user_id) 
           VALUES (?, ?, ?, ?, ?, ?, ?)""",
        (invoice_id, payment_address, amount, "pending", now, expires_at, user_id)
    )
    conn.commit()
    conn.close()
    
    logger.info(f"새 인보이스 생성: {invoice_id}, 금액: {amount} BCH, 사용자: {user_id}")
    
    # 응답 반환
    if request.headers.get('Accept', '').find('application/json') != -1:
        return jsonify(invoice_data)
    else:
        return redirect(url_for('view_invoice', invoice_id=invoice_id))

@app.route('/invoice/<invoice_id>')
def view_invoice(invoice_id):
    """인보이스 조회 페이지"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT id, payment_address, amount, status, created_at, expires_at, paid_at, user_id, tx_hash, confirmations
        FROM invoices WHERE id = ?
    """, (invoice_id,))
    
    result = cursor.fetchone()
    conn.close()
    
    if not result:
        return render_template('error.html', message="인보이스를 찾을 수 없습니다"), 404
    
    # 인보이스 데이터
    invoice = {
        "invoice_id": result[0],
        "payment_address": result[1],
        "amount": result[2],
        "status": result[3],
        "created_at": result[4],
        "expires_at": result[5],
        "paid_at": result[6],
        "user_id": result[7],
        "tx_hash": result[8],
        "confirmations": result[9]
    }
    
    # QR 코드 생성
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    
    # BCH URI 스키마
    qr_content = f"{invoice['payment_address']}?amount={invoice['amount']}"
    qr.add_data(qr_content)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    buffered = BytesIO()
    img.save(buffered)
    img_str = base64.b64encode(buffered.getvalue()).decode()
    
    # 만료 시간 포맷팅
    expiry_time = datetime.fromtimestamp(invoice['expires_at'])
    formatted_expiry = expiry_time.strftime('%Y-%m-%d %H:%M:%S')
    
    return render_template(
        'invoice.html', 
        invoice=invoice,
        qr_code=img_str,
        formatted_expiry=formatted_expiry,
        min_confirmations=MIN_CONFIRMATIONS,
        testnet=TESTNET
    )

@app.route('/check_payment/<invoice_id>', methods=['GET'])
def check_payment(invoice_id):
    """결제 상태 확인 - 개선된 로직"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, payment_address, amount, status, created_at, expires_at, paid_at, user_id, tx_hash, confirmations
            FROM invoices WHERE id = ?
        """, (invoice_id,))
        
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return jsonify({"error": "Invoice not found"}), 404
        
        invoice = {
            "invoice_id": result[0],
            "payment_address": result[1],
            "amount": result[2],
            "status": result[3],
            "created_at": result[4],
            "expires_at": result[5],
            "paid_at": result[6],
            "user_id": result[7],
            "tx_hash": result[8],
            "confirmations": result[9]
        }
        
        # 이미 완료된 경우
        if invoice["status"] == "completed":
            conn.close()
            return jsonify(invoice)
        
        # 지불 확인된 경우 (paid 상태)
        if invoice["status"] == "paid":
            # 트랜잭션 확인 수 업데이트
            if invoice["tx_hash"]:
                # 기본적인 확인 수 확인
                confirmations = direct_payment_handler.get_transaction_confirmations(invoice["tx_hash"])
                
                # 기존 확인 수와 다르면 업데이트
                if confirmations != invoice["confirmations"]:
                    cursor.execute(
                        "UPDATE invoices SET confirmations = ? WHERE id = ?",
                        (confirmations, invoice_id)
                    )
                    invoice["confirmations"] = confirmations
                    
                # 충분한 확인이 없으면 확장 검증 시도
                if confirmations < MIN_CONFIRMATIONS:
                    # 추가 검증 로직 수행
                    verified = direct_payment_handler.complete_payment_verification(
                        invoice_id, 
                        invoice["tx_hash"], 
                        invoice["payment_address"], 
                        float(invoice["amount"]), 
                        MIN_CONFIRMATIONS
                    )
                    
                    # 확장 검증에 성공한 경우
                    if verified:
                        confirmations = MIN_CONFIRMATIONS  # 확인됨으로 처리
                        cursor.execute(
                            "UPDATE invoices SET confirmations = ? WHERE id = ?",
                            (confirmations, invoice_id)
                        )
                        invoice["confirmations"] = confirmations
                
                # 충분한 확인이 되면 완료 처리
                if confirmations >= MIN_CONFIRMATIONS:
                    cursor.execute(
                        "UPDATE invoices SET status = 'completed' WHERE id = ?",
                        (invoice_id,)
                    )
                    invoice["status"] = "completed"
                    
                    # 사용자 크레딧 추가
                    if invoice["user_id"]:
                        credit_user(invoice["user_id"], invoice["amount"], invoice_id)
            
            conn.commit()
            conn.close()
            return jsonify(invoice)
        
        # 대기 중인 경우: 트랜잭션 검색
        logger.info(f"인보이스 {invoice_id}의 결제 상태 확인 중...")
        
        # 인보이스 생성 시간 처리
        created_at = invoice["created_at"]
        # ISO 형식 날짜를 타임스탬프로 변환
        from datetime import datetime
        if isinstance(created_at, str):
            try:
                # ISO 형식 날짜 처리
                if 'T' in created_at or '-' in created_at:
                    created_at_timestamp = int(datetime.fromisoformat(created_at.replace('Z', '+00:00')).timestamp())
                else:
                    # 이미 타임스탬프인 경우
                    created_at_timestamp = int(created_at)
            except Exception:
                # 변환 실패 시 현재 시간 - 1시간 사용
                import time
                created_at_timestamp = int(time.time()) - 3600
        else:
            # 타임스탬프로 직접 사용
            created_at_timestamp = int(created_at)
        
        # 트랜잭션 검색
        tx_info = direct_payment_handler.find_payment_transaction(
            invoice["payment_address"], 
            float(invoice["amount"]),
            created_at_timestamp
        )
        
        if tx_info:
            # 지불 확인
            paid_at = int(time.time())
            tx_hash = tx_info["txid"]
            confirmations = tx_info["confirmations"]
            
            cursor.execute(
                "UPDATE invoices SET status = 'paid', paid_at = ?, tx_hash = ?, confirmations = ? WHERE id = ?",
                (paid_at, tx_hash, confirmations, invoice_id)
            )
            
            invoice["status"] = "paid"
            invoice["paid_at"] = paid_at
            invoice["tx_hash"] = tx_hash
            invoice["confirmations"] = confirmations
            
            # 확인 수가 부족하면 확장 검증 시도
            if confirmations < MIN_CONFIRMATIONS:
                verified = direct_payment_handler.complete_payment_verification(
                    invoice_id, 
                    tx_hash, 
                    invoice["payment_address"], 
                    float(invoice["amount"]), 
                    MIN_CONFIRMATIONS
                )
                
                # 확장 검증 성공 시 완료로 처리
                if verified:
                    confirmations = MIN_CONFIRMATIONS  # 충분히 확인됨
                    cursor.execute(
                        "UPDATE invoices SET confirmations = ? WHERE id = ?",
                        (confirmations, invoice_id)
                    )
                    invoice["confirmations"] = confirmations
            
            # 충분한 확인이 있으면 완료로 처리
            if confirmations >= MIN_CONFIRMATIONS:
                cursor.execute(
                    "UPDATE invoices SET status = 'completed' WHERE id = ?",
                    (invoice_id,)
                )
                invoice["status"] = "completed"
                
                
                # 사용자 크레딧 추가
                if invoice["user_id"]:
                    credit_user(invoice["user_id"], invoice["amount"], invoice_id)
        
        # PoW 검증 확인 (작업 증명 사용 여부 확인)
        else:
            try:
                # 테이블이 존재하는지 확인
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='pow_verifications'")
                pow_table_exists = cursor.fetchone() is not None
        
                if pow_table_exists:
                    # 컬럼 목록 가져오기 (로깅용)
                    cursor.execute("PRAGMA table_info(pow_verifications)")
                    columns = [column[1] for column in cursor.fetchall()]
                    logger.info(f"pow_verifications 테이블 컬럼: {columns}")
            
                    # 인보이스에 대한 검증 기록이 있는지만 확인
                    # 현재 테이블 구조에는 verified 컬럼이 없으므로
                    # 단순히 인보이스 ID에 해당하는 레코드가 있는지만 확인
                    cursor.execute("SELECT id FROM pow_verifications WHERE invoice_id = ?", (invoice_id,))
                    pow_record = cursor.fetchone()
            
                    if pow_record:
                        # 레코드가 있으면 작업 증명이 검증된 것으로 간주
                        invoice["pow_verified"] = True
                        logger.info(f"인보이스 {invoice_id}의 작업 증명 기록이 확인되었습니다.")
            except Exception as e:
                logger.error(f"PoW 검증 확인 중 오류: {str(e)}")
                # 오류 발생 시 PoW 검증 무시하고 계속 진행
                pass
        
        conn.commit()
        conn.close()
        return jsonify(invoice)
        
    except Exception as e:
        logger.error(f"결제 상태 확인 오류: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": "결제 상태 확인 중 오류가 발생했습니다."}), 500

def credit_user(user_id, amount, invoice_id):
    """사용자 계정에 크레딧 추가"""
    if not user_id:
        return False
        
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # 현재 시간
    now = int(time.time())
    
    # 사용자 크레딧 업데이트
    cursor.execute(
        "INSERT INTO user_credits (user_id, credit_balance, last_updated) VALUES (?, ?, ?) "
        "ON CONFLICT(user_id) DO UPDATE SET credit_balance = credit_balance + ?, last_updated = ?",
        (user_id, amount, now, amount, now)
    )
    
    # 트랜잭션 기록 저장
    transaction_id = str(uuid.uuid4())
    cursor.execute(
        "INSERT INTO transactions (id, user_id, amount, type, description, created_at, invoice_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (transaction_id, user_id, amount, "credit", "Bitcoin Cash 충전", now, invoice_id)
    )
    
    conn.commit()
    conn.close()
    
    # Lemmy API 통합 (실제 구현 필요)
    if LEMMY_API_KEY:
        try:
            # Lemmy API를 통해 사용자 포인트 증가 처리
            logger.info(f"Lemmy API 호출: 사용자 {user_id}에게 {amount} 크레딧 추가")
            # TODO: Lemmy API 호출 구현
        except Exception as e:
            logger.error(f"Lemmy API 호출 오류: {str(e)}")
    
    logger.info(f"사용자 {user_id}에게 {amount} BCH 크레딧 추가됨, 인보이스: {invoice_id}")
    return True

@app.route('/api/user_credit/<user_id>', methods=['GET'])
@require_api_key
def get_user_credit(user_id):
    """사용자 크레딧 조회 API"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT credit_balance FROM user_credits WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if not result:
        return jsonify({"user_id": user_id, "credit_balance": 0})
    
    return jsonify({"user_id": user_id, "credit_balance": result[0]})

@app.route('/api/transactions/<user_id>', methods=['GET'])
@require_api_key
def get_user_transactions(user_id):
    """사용자 거래 내역 조회 API"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id, amount, type, description, created_at FROM transactions WHERE user_id = ? ORDER BY created_at DESC LIMIT 50", 
        (user_id,)
    )
    results = cursor.fetchall()
    conn.close()
    
    transactions = [
        {
            "id": row[0],
            "amount": row[1],
            "type": row[2],
            "description": row[3],
            "created_at": row[4],
            "date": datetime.fromtimestamp(row[4]).strftime('%Y-%m-%d %H:%M:%S')
        }
        for row in results
    ]
    
    return jsonify({"user_id": user_id, "transactions": transactions})

# 만료된 인보이스 정리 함수
def cleanup_expired_invoices():
    """만료된 인보이스 처리"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    now = int(time.time())
    cursor.execute(
        "UPDATE invoices SET status = 'expired' WHERE status = 'pending' AND expires_at < ?", 
        (now,)
    )
    
    count = cursor.rowcount
    conn.commit()
    conn.close()
    
    if count > 0:
        logger.info(f"{count}개의 만료된 인보이스 처리됨")

@app.route('/verify-payment', methods=['POST'])
def verify_payment_pow():
    """작업 증명을 통한 결제 검증"""
    try:
        data = request.json
        if not data:
            return jsonify({'verified': False, 'reason': '요청 데이터가 없습니다'}), 400
            
        payment_id = data.get('paymentId')
        user_token = data.get('userToken')
        nonce = data.get('nonce')
        claimed_hash = data.get('hash')
        
        logger.info(f"작업 증명 검증 요청: 인보이스 {payment_id}, 토큰 {user_token}")
        
        # 1. 결제 ID 유효성 확인
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, payment_address, amount, status, created_at, user_id
            FROM invoices WHERE id = ?
        """, (payment_id,))
        
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            logger.warning(f"작업 증명 검증 실패: 인보이스 {payment_id} 없음")
            return jsonify({'verified': False, 'reason': '인보이스를 찾을 수 없습니다'})
        
        invoice = {
            "id": result[0],
            "payment_address": result[1],
            "amount": result[2],
            "status": result[3],
            "created_at": result[4],
            "user_id": result[5]
        }
        
        # 이미 완료된 경우
        if invoice["status"] == "completed":
            conn.close()
            return jsonify({'verified': True})
        
        # 만료된 경우
        if invoice["status"] == "expired":
            conn.close()
            logger.warning(f"작업 증명 검증 실패: 인보이스 {payment_id} 만료됨")
            return jsonify({'verified': False, 'reason': '인보이스가 만료되었습니다'})
        
        # 2. PoW 해시 검증
        difficulty = 4  # 서버에서 설정한 난이도
        target = '0' * difficulty
        
        # 해시 재계산하여 검증
        data_string = f"{payment_id}:{user_token}:{nonce}"
        computed_hash = hashlib.sha256(data_string.encode()).hexdigest()
        
        if computed_hash != claimed_hash or not computed_hash.startswith(target):
            conn.close()
            logger.warning(f"작업 증명 검증 실패: 유효하지 않은 해시 {computed_hash}")
            return jsonify({'verified': False, 'reason': '유효하지 않은 작업 증명입니다'})
        
        logger.info(f"작업 증명 해시 검증 성공: {computed_hash}")
        
        # 3. 블록체인 결제 확인 시도
        try:
            # 직접 결제 모드로 트랜잭션 확인
            tx_info = direct_payment_handler.find_payment_transaction(
                invoice["payment_address"], 
                invoice["amount"],
                invoice["created_at"]
            )
            
            if tx_info:
                # 결제 확인됨, 인보이스 상태 업데이트
                now = int(time.time())
                cursor.execute(
                    "UPDATE invoices SET status = 'paid', paid_at = ?, tx_hash = ?, confirmations = ? WHERE id = ?",
                    (now, tx_info["txid"], tx_info["confirmations"], payment_id)
                )
                
                # 충분한 확인이 있으면 완료로 처리
                if tx_info["confirmations"] >= MIN_CONFIRMATIONS:
                    cursor.execute(
                        "UPDATE invoices SET status = 'completed' WHERE id = ?",
                        (payment_id,)
                    )
                    
                    # 사용자 크레딧 추가
                    if invoice["user_id"]:
                        credit_user(invoice["user_id"], invoice["amount"], payment_id)
                
                conn.commit()
                conn.close()
                logger.info(f"블록체인 결제 확인 성공: 인보이스 {payment_id}, 트랜잭션 {tx_info['txid']}")
                return jsonify({'verified': True})
            else:
                # PoW는 성공했지만 실제 결제는 확인되지 않음
                # 작업 증명 정보 저장
                pow_id = str(uuid.uuid4())
                cursor.execute(
                    """INSERT INTO pow_verifications 
                       (id, invoice_id, nonce, hash, verified_at, user_token) 
                       VALUES (?, ?, ?, ?, ?, ?)""",
                    (pow_id, payment_id, nonce, computed_hash, int(time.time()), user_token)
                )
                conn.commit()
                conn.close()
                
                logger.info(f"작업 증명은 성공했으나 블록체인 결제 미확인: 인보이스 {payment_id}")
                return jsonify({
                    'verified': False, 
                    'powVerified': True,
                    'reason': '작업 증명은 확인되었으나 블록체인에서 결제가 확인되지 않았습니다'
                })
        except Exception as e:
            logger.error(f"결제 확인 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            
            # API 오류 등 발생 시, PoW로 결제 승인 (백그라운드에서 나중에 확인)
            now = int(time.time())
            pow_id = str(uuid.uuid4())
            
            # PoW 정보 저장
            cursor.execute(
                """INSERT INTO pow_verifications 
                   (id, invoice_id, nonce, hash, verified_at, user_token) 
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (pow_id, payment_id, nonce, computed_hash, now, user_token)
            )
            
            # 인보이스 상태 업데이트
            cursor.execute(
                "UPDATE invoices SET status = 'pow_verified', paid_at = ? WHERE id = ?",
                (now, payment_id)
            )
            
            # 사용자 크레딧 추가 (블록체인 확인이 실패하더라도 PoW로 임시 승인)
            if invoice["user_id"]:
                cursor.execute(
                    "INSERT INTO pow_credits (invoice_id, user_id, amount, created_at) VALUES (?, ?, ?, ?)",
                    (payment_id, invoice["user_id"], invoice["amount"], now)
                )
            
            conn.commit()
            conn.close()
            
            logger.info(f"API 오류로 작업 증명을 통한 결제 임시 승인: 인보이스 {payment_id}")
            return jsonify({
                'verified': True,
                'method': 'proof_of_work',
                'message': '작업 증명을 통해 결제가 승인되었습니다. 블록체인 확인은 나중에 진행됩니다.'
            })
    except Exception as e:
        logger.error(f"전체 검증 과정 오류: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'verified': False, 'reason': f'서버 오류: {str(e)}'}), 500

@app.route('/debug-transaction', methods=['POST'])
def debug_transaction():
    """트랜잭션 디버깅 API"""
    try:
        tx_hash = request.json.get('tx_hash')
        app.logger.info(f"트랜잭션 디버깅: {tx_hash}")
        
        from direct_payment import check_transaction_blockchair
        result = check_transaction_blockchair(tx_hash)
        
        app.logger.info(f"디버깅 결과: {result}")
        return jsonify({"debug_result": result})
    except Exception as e:
        app.logger.error(f"디버깅 오류: {str(e)}")
        app.logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

# 주기적 작업 스레드
def background_tasks():
    """백그라운드 작업 처리"""
    while True:
        try:
            # 만료된 인보이스 처리
            cleanup_expired_invoices()
            
            # 대기 중인 인보이스 상태 확인
            conn = sqlite3.connect(DB_PATH)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id FROM invoices WHERE status = 'pending'"
            )
            pending_invoices = [row[0] for row in cursor.fetchall()]
            conn.close()
            
            for invoice_id in pending_invoices:
                check_payment(invoice_id)
                
            # 지불 확인된 인보이스의 트랜잭션 확인 수 업데이트
            conn = sqlite3.connect(DB_PATH)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, tx_hash FROM invoices WHERE status = 'paid'"
            )
            paid_invoices = [(row[0], row[1]) for row in cursor.fetchall()]
            conn.close()
            
            for invoice_id, tx_hash in paid_invoices:
                if tx_hash and not tx_hash.startswith("mock_tx_"):
                    confirmations = direct_payment_handler.get_transaction_confirmations(tx_hash)
                    
                    conn = sqlite3.connect(DB_PATH)
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE invoices SET confirmations = ? WHERE id = ?",
                        (confirmations, invoice_id)
                    )
                    
                    # 충분한 확인이 되면 완료 처리
                    if confirmations >= MIN_CONFIRMATIONS:
                        cursor.execute(
                            "SELECT user_id, amount FROM invoices WHERE id = ?",
                            (invoice_id,)
                        )
                        result = cursor.fetchone()
                        
                        if result:
                            user_id, amount = result
                            cursor.execute(
                                "UPDATE invoices SET status = 'completed' WHERE id = ?",
                                (invoice_id,)
                            )
                            
                            # 사용자 크레딧 추가
                            if user_id:
                                credit_user(user_id, amount, invoice_id)
                    
                    conn.commit()
                    conn.close()
            
        except Exception as e:
            logger.error(f"백그라운드 작업 오류: {str(e)}")
            logger.error(traceback.format_exc())
        
        # 5분마다 실행
        time.sleep(300)
        
@app.route('/admin/update-schema', methods=['GET'])
def update_schema():
    """데이터베이스 스키마 업데이트 (임시 관리자 엔드포인트)"""
    try:
        # 보안 키 확인 (간단한 보안 - 실제로는 더 강력한 인증이 필요)
        key = request.args.get('key')
        if not key or key != os.environ.get('ADMIN_KEY', 'temporary_admin_key'):
            return jsonify({"error": "Unauthorized"}), 401
        
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # 1. pow_verifications 테이블 구조 확인
        cursor.execute("PRAGMA table_info(pow_verifications)")
        columns = [column[1] for column in cursor.fetchall()]
        logger.info(f"기존 pow_verifications 컬럼: {columns}")
        
        changes = []
        
        # 2. verified 컬럼 추가 (없는 경우)
        if 'verified' not in columns:
            cursor.execute("ALTER TABLE pow_verifications ADD COLUMN verified INTEGER DEFAULT 1")
            changes.append("Added 'verified' column to pow_verifications")
        
        # 3. 다른 테이블 구조 확인 및 필요한 변경사항 적용
        # 예: invoices 테이블의 created_at 타입 확인 등
        
        cursor.execute("PRAGMA table_info(invoices)")
        invoice_columns = {col[1]: col[2] for col in cursor.fetchall()}
        logger.info(f"invoices 테이블 컬럼: {invoice_columns}")
        
        # 타입 변환이 필요한 경우 처리
        # 참고: SQLite는 ALTER TABLE로 컬럼 타입 변경이 불가능하므로
        # 테이블 재생성이 필요할 수 있습니다
        
        conn.commit()
        conn.close()
        
        # 변경 결과 반환
        if changes:
            return jsonify({
                "success": True,
                "message": "스키마가 업데이트되었습니다.",
                "changes": changes
            })
        else:
            return jsonify({
                "success": True,
                "message": "스키마가 이미 최신 상태입니다.",
                "changes": []
            })
    
    except Exception as e:
        logger.error(f"스키마 업데이트 오류: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": f"스키마 업데이트 중 오류가 발생했습니다: {str(e)}"}), 500

if __name__ == "__main__":
    # 데이터 디렉토리 생성
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    
    # 백그라운드 작업 시작
    cleanup_thread = threading.Thread(target=background_tasks)
    cleanup_thread.daemon = True
    cleanup_thread.start()
    
    # 앱 실행
    debug_mode = os.environ.get('FLASK_ENV', 'production') == 'development'
    app.run(host="0.0.0.0", port=8081, debug=debug_mode)